# 服务开发规范

## Handler 层

`handler`  层的作用比较单一，它是 RPC 服务暴露给其他服务的接口，需要做的事情包括

* 参数的校验，主要是入参

* 接口入参数据往服务对应使用模型的转换

* 调用 `service` 层执行具体的业务

* 接口出参的数据转换和整合处理

可以看出 `handler` 层不需要处理具体的业务逻辑，主要是数据的转换，这样做的目的是做到 `IDL` 和服务内部使用的模型解耦，防止上游或者下游模型改动影响到服务本身。

## Service 层

`service` 层是核心业务逻辑层，在这里去处理和业务相关的复杂的定制的逻辑。这里面可以继续细分成两个更小的逻辑场景：通用逻辑和定制逻辑。对于通用逻辑指的就是可以抽象出来给不同 `service` 去使用的，比如 `RPC` 的调用和返回数据的预处理。在 go 中可以用 `interface` 的形式。定制逻辑一般就是逻辑的组合编排，可以是通用逻辑+特殊定制。

在很多时候，会将通用逻辑和定制逻辑从服务层级上就分开，定制逻辑层即是 `service` 层，而通用逻辑层是 `repository` 层。通用逻辑层会去尝试获取资源，完成返回的预处理，并且将外部资源进行整合，这里就包括把外部 `RPC` 返回的结构专程服务内部使用结构，把数据库返回结构 `PO(Persistent Object)` 转成内部使用结构 `BO(Business Object)` 等等。**一个基本原则就是所有外部非结构均不能直接在服务内部的业务中直接使用**。

## Data 层

即是熟知的 DAL(data access layer)。这里可以分为两个大类，一个是与存储相关的，另一个是和其他服务相关的。

### 数据存储层

和存储相关的 `mysql`，`redis`，`cache` 等，所有的初始化，`CRUD` 操作都应该收敛到该目录下进行处理。**注意所有的逻辑都不应该和业务层耦合**，这里只是单一对数据进行处理，封装成相应的 interface 供其他使用，换句话说，它可以在一开始就完成一部分，并且由完全独立于项目开发的人完成。存储层需要直接对和数据存储本身相关的错误进行检查。

### 第三方调用层

常说的 `thirdcall`。负责调用其他的 `RPC / HTTP` 服务。同数据存储层一样，不应该和业务逻辑耦合，只需要完成外部服务的连接初始化和对应的接口调用即可。**这一层的输入输出都是业务使用的结构，所有对应转换都在这一层内部完成**。

## Model 层

数据模型层。这里面定义了所有服务内部使用的数据模型，为了方便区分可以在它下面新增二级目录，分清各个使用场景。

## Common 层

通用能力封装层。包括模型转换器，通用异常处理，和业务有关/无关的通用逻辑。例如字符串的序列化与反序列化，类型反射，映射对应关系都可以放在这里。同样，为了使逻辑更加清晰，强烈建议根据使用场景增加二级目录。

## Const 层

常量层。原则上项目中使用的所有常量，枚举值，自定义错误，错误码都收敛到该目录下。

## Config 层

所有配置文件放在该目录下
